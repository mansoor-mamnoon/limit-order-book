# Benchmarks (v0)

**Host**: <your laptop model/CPU, cores/threads, RAM>  
**OS/Compiler**: <e.g., macOS 14.x, Apple Clang 15 | Ubuntu 24.04, clang-18>  
**Build**: Release with: -O3 -march=native -fno-exceptions -fno-rtti -DNDEBUG (profiling frame pointers enabled)

## Method
- Synthetic limit-order stream with --warmup 50000 and --msgs 2000000.
- Price band ~25 ticks around mid; FIFO per level; STP off for bench.
- Metrics: throughput (msgs/s), latency percentiles (µs), histogram (0–100 µs).

## Command & Results
$ ./build/cpp/bench_tool --msgs 2000000 --warmup 50000 --out-csv docs/bench.csv --hist docs/hist.csv
Run A:
msgs=2000000, time=0.156s, rate=12854458.3 msgs/s
latency_us: p50=0.04 p90=0.08 p99=0.08 p99.9=0.12

## Percentiles (from docs/bench.csv)
Percentile | µs
---------- | ---
50         | 0.04
90         | 0.08
99         | 0.08
99.9       | 0.12

## Histogram (0–100 µs)
See docs/hist.csv (columns: bucket_us,count), generated by the command above.

## Notes
- Memory pools eliminated allocator overhead in the hot path.
- Best-level pointer cache avoids per-iteration map/array lookups.
- Side-specialized matching collapses branches in the inner loop.
- Frame pointers are enabled for clean profiling when needed.

## Artifacts
- docs/bench.csv   (created by --out-csv docs/bench.csv)
- docs/hist.csv    (created by --hist docs/hist.csv)